# Case 4
## К письменной работе №2.
### Выполнено студентом Московского университета имени С.Ю.Витте, Аверьяновым Леонидом Евгеньевичем. 
#### Прикладная инофрматика, 1 курс.

1. Исходный код, а так-же скомпилированный вариант программы находятся в той же директории, что и этот файл с именами "ex4.c" и "ex4" соответственно.  
Сборка производилась с помощью gcc 5.4.0 со следующими флагами:  
`gcc --std=c89 ex4.c -o ex4 -lm`  

2. Программа проверялась сравнением вывода fSinX( x ) и sin( x ) из <math.h>.

    Проверка 1.  
	Input X: 5  
	Input E: 50  
	fSinX( x ): -0.958924  
	sin( x ): -0.958924  
    Проверка 2:  
	Input X: 12  
	Input E: 50  
	fSinX( x ):-0.536573  
	sin( x ):-0.536573  
    Проверка 3:  
	Input X: -5    
	Input E: 50  
	fSinX( x ):0.958924  
	sin( x ):0.958924  
    Проверка 4:  
	Input X: -60  
	Input E: 500  
	fSinX( x ):-nan  
	sin( x ):0.304811  

    Вывод: программа работает корректно, с оговорками. 
Для вычисления синуса числа недостаточно использовать лишь ряд тейлора. Этот код очень сложный. Ни один программный алгоритм не является точным во всем диапазоне значений x, поэтому в библиотеках реализуется множество различных алгоритмов, и первая задача - посмотреть на x и решить, какой алгоритм использовать. В некоторых регионах он использует то, что выглядит как знакомая серия Тейлора. Некоторые из алгоритмов сначала вычисляют быстрый результат, а затем, если это недостаточно точное, отбросьте его и отбросьте на более медленный алгоритм.

	https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/ieee754/dbl-64/s_sin.c;hb=HEAD#l281

3. >В чем достоинства двухсвязных и кольцевых списков?   

	Двусвязных - работа со списком в двух направлениях.
	Кольцевых - требуют меньше памяти чем двусвящные при равном количестве элементов.

	>...какие изменения в программе потребуются для их реализации?    

	Объявить структуру, которая будет являться списком. Записывать каждую итерацию вычисления как отдельный элемент списка. В таком случае будет сохраняться возможность получить результат разной точности от 0 до N в случае, если список будет сохраняться в памяти. Вот только зачем? 